	前台页面首先通过表单事件触发大C区的方法，后将表单数据也就是前台M中的model组合实体类Vo（可能与数据库表不一致），通过双向绑定，使c区收到数据后通过依赖注入service中的$http{请求}客户端发送请求，之后根据IP端口和具体的方法的路径进行访问，而访问我们springcloud请求首先通过的就是网关getway，说到网关就要提起跨域问题，跨域就是url中IP端口协议一个发生变化即为跨域js---js、js---java都属于跨域，跨域也就是发一个二次请求在真正的请求到前进行判断对于网关中的配置是否吻合（可以配置允许的网路、是否从服务器中获取cookie、请求方法、请求头）有效时长等等，后就是网关有三大功能检验fiter请求、断言、路由，校验以单点的登录来说也就是校验token令牌，验证不通过就是直接得响应了给一个缓和的页面或者登录页面不是用户真正要的，通过就进行断言看方法路径或者二级域名进行路由lb：服务名，因为是集群项目所以需要去注册中心nacos获取porduct服务名而nacos是在另一台服务器中由运维人员或者自己搭建，请求到达porduct首先将model（MO和数据库对应）和工具类先引入，然后就是pom、yam、mapper、主启动也叫主配置类，service、impl、controller接收到前台的数据，组合实体类，最后S、M结合访问数据库进行一对多的添加。
	具体业务：前面已经大概说了属性和属性值的添加现在具体说属性和属性值也就是多表的添加，目前业务为两张表，就是一对多的添加，而谈到多表首先要提到的就是控制事务，而事务又分为本地事务和全局事务，目前我们的项目使用的是本地事务，事务之后就是表单数据的添加了，先插一表，在遍历插多表，最后将一的id插入多表中形成外键，入库添加完成，接下来就是spu和sku的保存，spu表示一个大的品牌比如苹果，而sku则表示分支系列11,12,13等等，其二者保存流程和代码也非常相似，区别是spu在一对多的基础上多了一个多，则会行程一对多对多，多嵌套了一层循环，另外sku的数据从spu中查询，spu的保存除了一对多的概念外还增加了一个图片的上传，
	图片上传有三个角色client客户端和tracker（踹可儿） serverstorage（死答瑞杰） server，storage server定时向tracker上传状态信息，client上传连接请求，tracker查询可用的storage后，将可用的storage的IP端口返回，然后client客户端上传文件，最后生成file_id，然后将上传内容写入磁盘最后还将路径信息和文件名返回给client进行保存。具体代码为先在yml文件中获取上传文件的IP端口，在准备一个tracker.conf里面是tracker服务器的IP和端口是在152虚拟服务器，里面可以设置超时时间，文件上传入参必须是MultipartFile，入参确定之后，获取tracker.conf判断是否为空，不为空首先进行初始化global，init创建trackerclient客户端，再用客户端获取trackerServer通过trackerServer获取storageClient1而storageClient也分为带1和不带1，带1则会帮你自动拼接不带1就要多一次遍历手动拼接，拼接完成就获取到了文件的相对路径最后拼上IP和端口保存就OK了。
	详情首先六个业务sku的基本信息、图片、价格、销售属性、sku分类信息，为了提高效率所以要在数据库中创建一个视图，即为只要有三的id就能查出对应的一级和二级，各个业务分别查询数据库，为了方便调用引入一个中台的概念通过fegin负载均衡后调用合适的product其中也包括fallback回调函数熔断降级，为了展示详情页出现weball模块，weball也通过fegin调用item，item在调用product，而详情最重要的还是两个函数一个if非空就赋值-1空就赋值0，is_choned
Group_concat分组根据|拼接。
	详情的进阶为了优化并提高效率所以我们使用了redis缓存和多线程的两个方法进行优化，使用Redis具体形式为当请求到达时先查询redis，如果没有数据，查询mysql数据库之后再将数据放入Redis中，此时又会出现redis自身的问题，穿透、雪崩、击穿，并且redis只能存储体积小不经常变化的（静态数据），何为穿透当查询redis时没有数据，之后查询mysql数据库时也没有，此时出现穿透了，我们是会创建一个临时的假对象存到redis中但时间不能过长因为我们要查redis和数据库同时高并发所以要出现了锁的概念首先使用的是本地锁，但是对于分布式集群框架来说本地锁出现了局限性,所以要是用分布式锁而分布式锁也需要优化，首先上锁后，线程枪到锁开始执行代码，，但中途如果出现异常锁所无法释放，所以设置锁的时间，手动释放锁，第二次优化则是为了防止误删，通过uuid给锁一个不同的id，第三次优化则为处理原子性当1的线程执行删除时，查到的1的id确实相同，这时锁的过期时间刚好达到Redis自动释放，1没了锁，2抢到锁开始执行，这时1的删除刚好吧2的删除了出现问题所以我们采用了lua脚本来解决原子性的问题，那么没抢到锁的线程我们会让它们睡一会，然后继续抢锁，称之为自旋锁。
	多线程这时我们为了提高效率，优化代码所以要用线程池，没用之前的运行时间就是所有的线程加起来的时间，当使用线程池后运行时间就是第一个加后面五个中的最大时间之和，因为后面线程要依赖第一个线程的结果，所以要等第一个线程结束后面才能开始，同时也要控制同时返回，所以再加一个阻塞线程。最后一个就是热点，热点即为详情页的点击量，为了防止es访问过多，十次存一次es，其他存在redis中。